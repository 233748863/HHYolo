# HHYolo 项目编译与开发指南

本文档将指导您如何配置开发环境、编译生成 `HHYolo.dll` 和 `OnnxFeature.dll`，以及如何为该项目添加新的 API 函数。

## 项目架构概述

当前项目包含两个独立的 DLL：

- **HHYolo.dll**: 核心功能库，提供图像识别、OCR、内存读取等功能
- **OnnxFeature.dll**: ONNX 推理插件，提供 AI 模型推理功能（目标检测和OCR文字识别）
- **依赖关系**: `OnnxFeature.dll` 依赖 `onnxruntime.dll` 运行时库

---

## 一、 环境准备 (Prerequisites)

在开始之前，请确保您的系统（Windows）上已安装以下软件：

1.  **Visual Studio 2022**:
    *   必须安装 **“使用 C++ 的桌面开发”** 工作负载。
    *   下载地址: [https://visualstudio.microsoft.com/zh-hans/vs/](https://visualstudio.microsoft.com/zh-hans/vs/)

2.  **CMake**:
    *   一个跨平台的构建系统生成工具。
    *   下载地址: [https://cmake.org/download/](https://cmake.org/download/)
    *   安装时，请确保勾选 **"Add CMake to the system PATH for all users"** 或 "for current user"，以便在命令行中直接使用 `cmake` 命令。

3.  **Git**:
    *   一个分布式版本控制系统，我们将用它来安装 vcpkg。
    *   下载地址: [https://git-scm.com/downloads](https://git-scm.com/downloads)

---

## 二、 依赖库安装 (vcpkg, OpenCV, Tesseract)

本项目使用 `vcpkg` 来管理 C++ 依赖库。我们将通过它来安装 `OpenCV` (用于图像处理) 和 `Tesseract` (用于OCR文字识别)。

### 步骤 1: 安装 vcpkg

打开一个命令行终端 (CMD 或 PowerShell)，执行以下命令将 vcpkg 克隆到 `C:\` 盘根目录。

```bash
# 切换到 C 盘根目录
cd C:\

# 从 GitHub 克隆 vcpkg
git clone https://github.com/microsoft/vcpkg.git
```

克隆完成后，执行 vcpkg 的引导脚本来完成安装。

```bash
# 进入 vcpkg 目录
cd vcpkg

# 执行引导脚本 (Windows)
.\bootstrap-vcpkg.bat
```

### 步骤 2: 安装依赖库 (OpenCV 和 Tesseract)

vcpkg 安装完成后，执行以下命令来安装本项目所需的 **32位静态链接版** 的 `OpenCV` 和 `Tesseract`。

> **注意**: 这个过程会自动下载所有库的源码并进行编译，根据您的电脑性能和网络状况，首次执行可能需要较长时间（10到30分钟不等）。

```cmd
:: 在 C:\vcpkg 目录下执行
vcpkg.exe install opencv:x86-windows-static tesseract:x86-windows-static
```

*   `opencv:x86-windows-static`: 安装 **32位 (x86)**、**静态 (`.lib`)** 版本的 OpenCV。最新版的 vcpkg 会自动安装 `core`, `imgproc`, `imgcodecs` 等核心模块，无需手动指定。
*   `tesseract:x86-windows-static`: 安装 **32位 (x86)**、**静态 (`.lib`)** 版本的 Tesseract OCR 引擎。

安装完成后，您还需要为 Tesseract 下载语言包。

### 步骤 3: 下载并配置 Tesseract 语言包

1.  **下载语言文件**:
    *   访问 Tesseract 官方语言包仓库：[https://github.com/tesseract-ocr/tessdata_fast](https://github.com/tesseract-ocr/tessdata_fast)
    *   根据您需要识别的语言，下载对应的 `.traineddata` 文件。例如，识别简体中文需要下载 `chi_sim.traineddata`。
2.  **创建 Tesseract 数据目录结构**: Tesseract 要求一个特定的文件夹结构，即它需要知道 `tessdata` 文件夹的 **父目录** 在哪里。
    *   **推荐方式**: 创建一个总的根目录（例如 `C:\tesseract-data`），然后在这个根目录里面创建一个名为 `tessdata` 的子文件夹。
    *   **最终目录结构**: `C:\tesseract-data\tessdata\`
3.  **放置语言文件**: 将您下载的 `.traineddata` 文件 (例如 `chi_sim.traineddata`) 移动到刚刚创建的 `tessdata` 文件夹中。
4.  **记住父目录路径**: 在后续调用 `Ocr` 或 `OcrFile` 等函数时，`tessdataPath` 参数需要传入的是 **`tessdata` 文件夹的父目录路径**。
    *   在上面的推荐结构中，父目录就是 `C:\tesseract-data`。
    *   如果您把 `tessdata` 文件夹直接放在了 E 盘根目录（`E:\tessdata`），那么它的父目录就是 `E:\`，调用时就应该传入 `"E:\\"`。

---

### 步骤 4: 管理预编译的 ONNX Runtime 库（高级）

本项目依赖特定版本的 ONNX Runtime (1.22.1 x86 版本)。如果您需要使用已有的预编译库而不是通过 vcpkg 编译，可以按照以下步骤创建自定义 port：

#### 步骤 4.1: 创建 Overlay 目录结构

在 PowerShell 中执行以下命令创建 overlay 目录：

```powershell
# 在 C:\vcpkg 目录下执行
mkdir C:\vcpkg\overlay-ports\onnxruntime-prebuilt
```

#### 步骤 4.2: 创建 portfile.cmake

在 `C:\vcpkg\overlay-ports\onnxruntime-prebuilt` 目录下创建 `portfile.cmake` 文件，内容如下：

```cmake
# 1. 定义变量（使用正斜杠！）
set(ONNXRUNTIME_ROOT "C:/onnxruntime-win-x86-1.22.1")

# 2. 验证路径是否存在（关键调试步骤）
if(NOT EXISTS "${ONNXRUNTIME_ROOT}")
    message(FATAL_ERROR "❌ 预编译库根目录不存在: ${ONNXRUNTIME_ROOT}")
endif()

# 3. 安装头文件
file(INSTALL "${ONNXRUNTIME_ROOT}/include/" DESTINATION "${CURRENT_PACKAGES_DIR}/include")

# 4. 安装库文件（.lib）
file(INSTALL "${ONNXRUNTIME_ROOT}/lib/" DESTINATION "${CURRENT_PACKAGES_DIR}/lib")
file(INSTALL "${ONNXRUNTIME_ROOT}/lib/" DESTINATION "${CURRENT_PACKAGES_DIR}/debug/lib")

# 5. 安装DLL（自动识别目录）
# 优先尝试 bin/ 目录，不存在则尝试 lib/ 目录
if(EXISTS "${ONNXRUNTIME_ROOT}/bin/onnxruntime.dll")
    file(INSTALL "${ONNXRUNTIME_ROOT}/bin/onnxruntime.dll" DESTINATION "${CURRENT_PACKAGES_DIR}/bin")
    file(INSTALL "${ONNXRUNTIME_ROOT}/bin/onnxruntime.dll" DESTINATION "${CURRENT_PACKAGES_DIR}/debug/bin")
elseif(EXISTS "${ONNXRUNTIME_ROOT}/lib/onnxruntime.dll")
    file(INSTALL "${ONNXRUNTIME_ROOT}/lib/onnxruntime.dll" DESTINATION "${CURRENT_PACKAGES_DIR}/bin")
    file(INSTALL "${ONNXRUNTIME_ROOT}/lib/onnxruntime.dll" DESTINATION "${CURRENT_PACKAGES_DIR}/debug/bin")
else()
    message(FATAL_ERROR "❌ 找不到 onnxruntime.dll，请检查下载的包结构！")
endif()

# 6. 创建版权文件
file(WRITE "${CURRENT_PACKAGES_DIR}/share/${PORT}/copyright" "ONNX Runtime Prebuilt 1.22.1")
```

#### 步骤 4.3: 创建 vcpkg.json

在同一个目录下创建 `vcpkg.json` 文件，内容如下：

```json
{
  "name": "onnxruntime-prebuilt",
  "version": "1.22.1",
  "description": "ONNX Runtime x86 prebuilt binaries"
}
```

#### 步骤 4.4: 安装自定义 port

在 PowerShell 中执行以下命令安装自定义 port：

```powershell
# 在 C:\vcpkg 目录下执行
.\vcpkg install onnxruntime-prebuilt:x86-windows --overlay-ports=C:\vcpkg\overlay-ports

#有可能要先清除缓存再安装
# 1. 删除失败的安装包
.\vcpkg remove onnxruntime-prebuilt:x86-windows --purge

# 2. 重新安装
.\vcpkg install onnxruntime-prebuilt:x86-windows --overlay-ports=C:\vcpkg\overlay-ports --clean-after-build
```

#### 集成到 Visual Studio 项目

安装完成后，无需手动配置路径，直接通过 vcpkg 自动集成：

**CMake 项目（推荐）**

```cmake
cmake_minimum_required(VERSION 3.18)
project(YOLOv11Detector)

find_package(onnxruntime CONFIG REQUIRED)  # 自动找到 vcpkg 安装的版本

add_library(YOLOv11Detector SHARED yolov11_detector.cpp)
target_link_libraries(YOLOv11Detector PRIVATE onnxruntime::onnxruntime)
```

**注意**: 使用预编译库时，请确保 ONNX Runtime 1.22.1 x86 版本已正确安装在 `C:/onnxruntime-win-x86-1.22.1` 目录下。

---

## 三、 编译项目 (推荐流程)

当所有环境和依赖都准备好后，请严格遵循以下步骤进行编译。这是经过验证的最可靠的流程，可以避免绝大多数环境问题。

1.  **打开“开发者命令提示符”**
    *   点击 Windows 的“开始”菜单。
    *   输入 `Developer Command Prompt for VS 2022` 并打开它。

2.  **在打开的黑色窗口中，执行以下命令**：
    将 `C:\path\to\your\project` 替换为您的项目实际路径 (例如 `C:\Users\Administrator\Desktop\comdll`)。

    ```cmd
    :: 1. 切换到您的项目目录
    cd C:\path\to\your\project
    
    :: 2. 如果存在旧的 build 目录，则彻底删除，确保干净的环境
    if exist build rmdir /s /q build
    
    :: 3. 创建一个新的 build 目录并进入
    mkdir build
    cd build
    
    :: 4. 运行 CMake 进行配置
    :: -A Win32 指定生成32位项目，与我们的32位库匹配
    :: -DCMAKE_TOOLCHAIN_FILE 指定 vcpkg 工具链，让 CMake 能找到所有库
    cmake .. -DCMAKE_TOOLCHAIN_FILE=C:/vcpkg/scripts/buildsystems/vcpkg.cmake -A Win32
    
    :: 5. 运行 CMake 进行编译 (Release 模式)
    cmake --build . --config Release
    ```

3.  **获取成果**
    编译成功后，将生成以下文件在 `build\Release\` 目录下：
    - `HHYolo.dll` (5.15 MB) - 主项目 DLL，静态链接 OpenCV 和 Tesseract
    - `HHYolo.lib` (4.2 KB) - 导入库文件
    - `OnnxFeature.dll` (3.75 MB) - ONNX 推理插件，静态链接 OpenCV
    - `OnnxFeature.lib` (2.21 KB) - 导入库文件
    - `onnxruntime.dll` (10.9 MB) - ONNX Runtime 运行时库（自动复制）

**部署说明：**
- 单独使用 `HHYolo.dll` 时，只需部署该文件即可
- 使用 `OnnxFeature.dll` 时，必须同时部署 `onnxruntime.dll`

---

## 四、 API 参考 (API Reference)

本节详细介绍 DLL 中所有公开的 API 函数。

### 1. `CaptureAndFindImage` (推荐)

对指定窗口句柄截图并在截图中查找模板图。这是最方便、最高效的自动化方法。

*   **C++ 签名:**
    ```cpp
    HHAPI int __stdcall CaptureAndFindImage(
        HWND hwnd,
        int roiX,
        int roiY,
        int roiWidth,
        int roiHeight,
        const char* tplPath,
        double similarity,
        int* matchX,
        int* matchY,
        double* confidence);
    ```
*   **参数:**
    *   `hwnd` (`HWND`): 目标窗口的句柄。
    *   `roiX`, `roiY`, `roiWidth`, `roiHeight` (`int`): 截图区域 (ROI)，坐标相对于窗口客户区。如果想截取整个窗口，请将 `roiX` 和 `roiY` 设为0，并将 `roiWidth` 和 `roiHeight` 设为窗口的客户区宽高。
    *   `tplPath` (`const char*`): 模板图像的本地文件路径。
    *   `similarity` (`double`): 相似度阈值 (0.0 ~ 1.0)。
    *   `matchX` (`int*`): 用于接收匹配位置 X 坐标的指针 (相对于窗口客户区)。
    *   `matchY` (`int*`): 用于接收匹配位置 Y 坐标的指针 (相对于窗口客户区)。
    *   `confidence` (`double*`): 用于接收匹配的置信度 (0.0 ~ 1.0)。
*   **返回值:**
    *   `1`: 成功找到。
    *   `0`: 未找到。
    *   `-1`: OpenCV 内部错误。
    *   `-2`: 无效参数 (如句柄无效、宽高为0等)。
    *   `-3`: GDI 图形对象创建失败。
    *   `-4`: 截图失败 (`BitBlt` failed)。
    *   `-5`: 内存分配失败。
*   **`dllcall` 示例:**
    ```
    // 假设 `窗口句柄` 已被赋值
    var 返回值 = dllcall(dll路径, "long", "CaptureAndFindImage",
        "long", 窗口句柄,      // HWND句柄
        "long", 0,            // 截图区域左上角 X
        "long", 0,            // 截图区域左上角 Y
        "long", 1024,         // 截图区域宽度
        "long", 768,          // 截图区域高度
        "char *", "C:\\path\\to\\template.png",
        "double", 0.9,
        "plong", x,
        "plong", y,
        "pdouble", confidence // 传出置信度
    )
    ```

### 2. `FindImageFromMem`

在内存中的图像数据中查找模板图。适用于从截图等非文件来源获取的图像。

*   **C++ 签名:**
    ```cpp
    HHAPI int __stdcall FindImageFromMem(
        const unsigned char* imgData,
        int imgWidth,
        int imgHeight,
        int imgChannels,
        const char* tplPath,
        double similarity,
        int* x,
        int* y,
        double* confidence);
    ```
*   **参数:**
    *   `imgData` (`const unsigned char*`): 指向主图像素数据的指针。
    *   `imgWidth` (`int`): 主图像的宽度。
    *   `imgHeight` (`int`): 主图像的高度。
    *   `imgChannels` (`int`): 主图像的通道数 (例如 3 for BGR, 4 for BGRA)。
    *   `tplPath` (`const char*`): 模板图像的本地文件路径。
    *   `similarity` (`double`): 相似度阈值。
    *   `x` (`int*`): 接收 X 坐标的指针。
    *   `y` (`int*`): 接收 Y 坐标的指针。
    *   `confidence` (`double*`): 用于接收匹配的置信度 (0.0 ~ 1.0)。
*   **返回值:** `1`=找到, `0`=未找到, `-1`=内部错误。
*   **`dllcall` 示例:**
    ```
    // 假设 `截图数据`, `图像宽度`, `图像高度`, `图像通道` 已被赋值
    var 返回值 = dllcall(dll路径, "long", "FindImageFromMem",
        "long", 截图数据,     // 内存数据指针
        "long", 图像宽度,
        "long", 图像高度,
        "long", 图像通道,
        "char *", "C:\\path\\to\\template.png",
        "double", 0.9,
        "plong", x,
        "plong", y,
        "pdouble", confidence
    )
    ```

### 3. `FindImage`

在本地磁盘上的主图中查找模板图。

*   **C++ 签名:**
    ```cpp
    HHAPI int __stdcall FindImage(
        const char* imgPath,
        const char* tplPath,
        double similarity,
        int* x,
        int* y,
        double* confidence);
    ```
*   **参数:**
    *   `imgPath` (`const char*`): 主图像的本地文件路径。
    *   `tplPath` (`const char*`): 模板图像的本地文件路径。
    *   `similarity` (`double`): 相似度阈值 (0.0 ~ 1.0)。
    *   `x` (`int*`): 用于接收匹配位置 X 坐标的指针。
    *   `y` (`int*`): 用于接收匹配位置 Y 坐标的指针。
    *   `confidence` (`double*`): 用于接收匹配的置信度 (0.0 ~ 1.0)。
*   **返回值:** `1`=找到, `0`=未找到, `-1`=内部错误。
*   **`dllcall` 示例:**
    ```
    var 返回值 = dllcall(dll路径, "long", "FindImage",
        "char *", "C:\\path\\to\\main_image.png",
        "char *", "C:\\path\\to\\template.png",
        "double", 0.9,
        "plong", x,
        "plong", y,
        "pdouble", confidence
    )
    ```

### 4. `CaptureAndFindAllImages`

对指定窗口截图并查找 **所有** 匹配的模板图，将结果格式化为字符串返回。

*   **C++ 签名:**
    ```cpp
    HHAPI const char* __stdcall CaptureAndFindAllImages(
        HWND hwnd,
        int roiX,
        int roiY,
        int roiWidth,
        int roiHeight,
        const char* tplPath,
        double similarity
    );
    ```
*   **参数:**
    *   `hwnd`, `roiX`, `roiY`, `roiWidth`, `roiHeight`, `tplPath`, `similarity`: 与 `CaptureAndFindImage` 相同。
*   **返回值 (`const char*`):**
    *   **成功**: 返回 `"数量;x1,y1,置信度1|x2,y2,置信度2..."` 格式的字符串。
    *   **未找到**: 返回 `"0;"`。
    *   **失败**: 返回固定的字符串 `"-1"`。
*   **`dllcall` 示例:**
    ```
    // 返回值类型是 "char *"
    var 结果字符串 = dllcall(dll路径, "char *", "CaptureAndFindAllImages",
        "long", 窗口句柄,
        "long", 0,            // roiX
        "long", 0,            // roiY
        "long", 1920,         // roiWidth
        "long", 1080,         // roiHeight
        "char *", "C:\\path\\to\\template.png",
        "double", 0.9
    )
    
    if (结果字符串 == "-1")
        traceprint("函数执行失败")
    else
        // 你可以在脚本里先按";"分割，第一部分是数量，第二部分是坐标
        traceprint("查找结果: ", 结果字符串)
    end
    ```

### 5. `ReadMemory`

根据给定的地址表达式，读取目标进程的内存，并将结果作为字符串返回。

*   **C++ 签名:**
    ```cpp
    HHAPI const char* __stdcall ReadMemory(
        HWND hwnd,
        const char* addressExpression,
        const char* readType,
        int readSize
    );
    ```
*   **参数:**
    *   `hwnd` (`HWND`): 目标窗口的句柄。
    *   `addressExpression` (`const char*`): 地址表达式字符串，格式为 `"[module.exe+offset]+offset1+offset2..."`。
    *   `readType` (`const char*`): 读取类型，单字符字符串：
        *   `"i"`: 整数 (配合 `readSize` 可读1, 2, 4, 8字节)。
        *   `"f"`: 单精度浮点数 (float, 4字节)。
        *   `"d"`: 双精度浮点数 (double, 8字节)。
        *   `"s"`: Ansi字符串 (需指定 `readSize`)。
        *   `"w"`: Unicode字符串 (需指定 `readSize`)。
    *   `readSize` (`int`): 读取的字节数。
*   **返回值 (`const char*`):**
    *   **成功**: 返回一个包含结果的字符串 (例如 `"12345"`)。
    *   **失败**: 返回固定的字符串 `"-1"`。
*   **`dllcall` 示例:**
    ```
    var 表达式 = "[JX3ClientX64.exe+8CD8D8]+10"
    
    // 正确的调用：返回值类型应为 "char *"，而不是 "string"
    var 结果 = dllcall(dll路径, "char *", "ReadMemory",
        "long", hwnd,
        "char *", 表达式,
        "char *", "i",  // 读取类型：整数
        "long", 4      // 读取长度：4字节
    )
    
    if (结果 == "-1")
        traceprint("读取内存失败")
    else
        traceprint("读取成功，值为: ", 结果)
    end
    ```

### 6. `CaptureAndFindMultiTemplates` (增强版)

在指定窗口的ROI区域内截图，并使用 **多个模板图片** 同时进行搜索，返回所有满足条件的匹配结果。这是功能最强大的API。

*   **C++ 签名:**
    ```cpp
    HHAPI const char* __stdcall CaptureAndFindMultiTemplates(
        HWND hwnd,
        int roiX, int roiY, int roiWidth, int roiHeight,
        const char* multiTplPaths,
        double similarity
    );
    ```
*   **参数:**
    *   `hwnd`, `roiX`, `roiY`, `roiWidth`, `roiHeight`, `similarity`: 与 `CaptureAndFindImage` 相同。
    *   `multiTplPaths` (`const char*`): **多模板路径字符串**。将所有模板图片的完整路径用 `|` 符号连接起来。
        *   **示例**: `"C:\\temp\\123.bmp|C:\\temp\\456.bmp"`
*   **返回值 (`const char*`):**
    *   **成功找到**: 返回一个格式化的字符串，包含所有匹配项的信息。
        *   **格式**: `"文件名1,x,y,置信度|文件名2,x,y,置信度|..."`
        *   **示例**: `"123.bmp,150,240,0.98|456.bmp,500,610,0.95"`
    *   **未找到**: 返回一个**空字符串** `""`。
    *   **执行失败**: 返回固定的字符串 `"-1"`。
*   **`dllcall` 示例:**
    ```
    var 模板们 = "C:\\temp\\123.bmp|C:\\temp\\456.bmp"
    
    // 返回值类型是 "char *"
    var 结果字符串 = dllcall(dll路径, "char *", "CaptureAndFindMultiTemplates",
        "long", 窗口句柄,
        "long", 0,            // roiX
        "long", 0,            // roiY
        "long", 1920,         // roiWidth
        "long", 1080,         // roiHeight
        "char *", 模板们,
        "double", 0.9
    )
    
    if (结果字符串 == "-1")
        traceprint("函数执行失败")
    else if (结果字符串 == "")
        traceprint("未找到任何匹配的图片")
    else
        // 你可以在脚本里按"|"分割来处理每一个匹配结果
        traceprint("查找结果: ", 结果字符串)
    end
    ```

### 7. `FindColor`

在指定坐标获取颜色，并与一个颜色列表进行匹配。函数会根据是否提供了有效的窗口句柄，自动判断坐标是相对坐标还是屏幕绝对坐标。

*   **C++ 签名:**
    ```cpp
    HHAPI const char* __stdcall FindColor(
        HWND hwnd,
        int x,
        int y,
        const char* colorStr
    );
    ```
*   **参数:**
    *   `hwnd` (`HWND`): 目标窗口的句柄。
        *   **如果提供一个有效的窗口句柄**：`x` 和 `y` 将被视为相对于该窗口客户区的 **相对坐标**。
        *   **如果此参数为 `0`**：`x` 和 `y` 将被视为 **屏幕绝对坐标**。
    *   `x`, `y` (`int`): 要检测的坐标。
    *   `colorStr` (`const char*`): 颜色匹配字符串，支持以下三种格式，函数会自动识别：
        1.  **分通道偏色 (推荐)**: `"RRGGBB-DR,DG,DB"` (例如: `"FF0000-10,5,20"`)
        2.  **紧凑分通道偏色**: `"RRGGBB-DRDGDB"` (例如: `"FF0000-100520"`, 每两位一个通道)
        3.  **单一偏色 (兼容旧版)**: `"RRGGBB-D"` (例如: `"FF0000-10"`)
*   **返回值 (`const char*`):**
    *   **成功找到匹配**: 返回由 `|` 分隔的、所有匹配颜色**索引**（从1开始）组成的字符串。例如：`"1|3"`。
    *   **未找到任何匹配**: 返回固定的字符串 **`"0"`**。
    *   **执行失败**: 返回固定的字符串 `"-1"`。
*   **`dllcall` 示例 (屏幕绝对坐标):**
    ```
    var 颜色列表 = "FFFFFF-10|00FF00-5"
    
    var 结果字符串 = dllcall(dll路径, "char *", "FindColor",
        "long", 0,          // 句柄传 0, 使用屏幕坐标
        "long", 500,        // 屏幕 X 坐标
        "long", 800,        // 屏幕 Y 坐标
        "char *", 颜色列表
    )
    
    if (结果字符串 == "-1")
        traceprint("函数执行失败")
    else if (结果字符串 == "0")
        traceprint("未找到匹配的颜色")
    else
        traceprint("匹配成功的颜色索引: ", 结果字符串)
    end
    ```
*   **`dllcall` 示例 (窗口相对坐标):**
    ```
    var 颜色列表 = "FFFFFF-10|00FF00-5"
    
    var 结果字符串 = dllcall(dll路径, "char *", "FindColor",
        "long", 窗口句柄,  // 传入有效的窗口句柄
        "long", 150,      // 窗口内 X 坐标
        "long", 300,      // 窗口内 Y 坐标
        "char *", 颜色列表
    )
    ```

### 8. `AnalyzeGrid` (重命名)

通过定位“锚点”图片，并基于固定的网格布局参数，批量分析网格中各个单元格的坐标和状态。这是一个为固定UI布局设计的、高性能的批量分析API。

*   **C++ 签名:**
    ```cpp
    HHAPI const char* __stdcall AnalyzeGrid(
        HWND hwnd,
        const char* anchorTplPath,
        double similarity,
        int gridRows,
        int gridCols,
        int firstCellOffsetX,
        int firstCellOffsetY,
        int cellWidth,
        int cellHeight,
        int horizontalGap,
        int verticalGap,
        int healthBarOffsetX,
        int healthBarOffsetY,
        int healthBarWidth,
        int healthBarHeight
    );
    ```
*   **参数 (需要您精确测量):**
    *   `hwnd` (`HWND`): 目标窗口句柄。
    *   `anchorTplPath` (`const char*`): 用于定位整个框架的锚点模板图片路径。
    *   `similarity` (`double`): 查找锚点的相似度阈值 (e.g., `0.9`)。
    *   **网格布局参数:**
        *   `gridRows`, `gridCols` (`int`): 网格的行数和列数 (e.g., `5`, `5`)。
        *   `firstCellOffsetX`, `firstCellOffsetY` (`int`): 从**锚点左上角**到**第一个格子左上角**的X, Y距离。
        *   `cellWidth`, `cellHeight` (`int`): **单个格子**的完整宽度和高度。
        *   `horizontalGap`, `verticalGap` (`int`): 格子间的**水平和垂直间距**。
            *   **详细解释**: 指的是一个玩家格子的**右边缘**到下一个相邻格子的**左边缘**（水平间距），或一个格子的**下边缘**到下一个格子的**上边缘**（垂直间距）之间的空白区域大小，以像素为单位。如果格子之间紧挨着没有缝隙，则该值为 `0`。
            *   **示意图**:
                ```text
                                 <---- horizontalGap ---->
                +-------------+   +-------------+
                |   格子 1    |   |   格子 2    |
                +-------------+   +-------------+
                      ^
                      |
                verticalGap
                      |
                      v
                +-------------+   +-------------+
                |   格子 4    |   |   格子 5    |
                +-------------+   +-------------+
                ```
    *   **血条内部参数:**
        *   `healthBarOffsetX`, `healthBarOffsetY` (`int`): 从**格子左上角**到其内部**血条区域左上角**的X, Y距离。
        *   `healthBarWidth`, `healthBarHeight` (`int`): **血条区域本身**的宽度和高度。
*   **返回值 (`const char*`):**
    *   **成功**: 返回格式化字符串 ` "centerX1,centerY1,health1|centerX2,centerY2,health2|..."`。
    *   **锚点未找到**: 返回 `"-1"`。
    *   **截图失败或其它错误**: 返回 `"-2"`。
*   **`dllcall` 示例:**
    ```
    var 结果字符串 = dllcall(dll路径, "char *", "AnalyzeGrid",
        "long", 窗口句柄,
        "char *", "C:\\path\\to\\anchor.bmp",
        "double", 0.9,
        "long", 5, "long", 5, // 网格行列
        "long", 10, "long", 50, // 第一个格子的偏移
        "long", 120, "long", 30, // 格子宽高
        "long", 5, "long", 5, // 间距
        "long", 15, "long", 20, // 血条在格子内的偏移
        "long", 100, "long", 8 // 血条自身宽高
    )
    
    if (结果字符串 == "-1")
        traceprint("锚点未找到")
    else if (结果字符串 == "-2")
        traceprint("函数执行失败")
    else
        traceprint("分析结果: ", 结果字符串)
    end
    ```

### 9. `Ocr` (原RecognizeText)

对指定区域进行OCR文本识别，返回所有识别到的文本及其坐标。

*   **C++ 签名:**
    ```cpp
    HHAPI const char* __stdcall Ocr(
        HWND hwnd,
        int roiX,
        int roiY,
        int roiWidth,
        int roiHeight,
        const char* lang,
        const char* tessdataPath
    );
    ```
*   **参数:**
    *   `hwnd` (`HWND`): 目标窗口的句柄。
    *   `roiX`, `roiY`, `roiWidth`, `roiHeight` (`int`): 要进行文字识别的区域 (ROI)，坐标相对于窗口客户区。
    *   `lang` (`const char*`): 识别语言。必须与您下载的 `.traineddata` 文件名对应。例如，使用 `chi_sim.traineddata` 时，此参数应为 `"chi_sim"`。
    *   `tessdataPath` (`const char*`): **`tessdata` 文件夹的父目录路径**。Tesseract API 要求传入包含 `tessdata` 文件夹的那个目录。
        *   **重要**: 请参考本文档 **“二、 依赖库安装”** -> **“步骤 3”** 中的目录结构说明。
        *   **示例 1 (推荐结构)**: 如果您按照指南将语言包放在 `C:\tesseract-data\tessdata\` 中，那么此参数应传入 `"C:\\tesseract-data"`。
        *   **示例 2 (自定义结构)**: 如果您的语言包直接放在 `E:\tessdata\` 中，那么 `tessdata` 文件夹的父目录就是 `E:\`，所以此参数应传入 `"E:\\"`。为了避免混淆，推荐使用示例1的结构。
*   **返回值 (`const char*`):**
    *   **成功**: 返回 `"文本1,centerX1,centerY1|文本2,centerX2,centerY2|..."` 格式的字符串。每个部分包含识别到的文本（已去除标点）和该文本块的中心点坐标。坐标是相对于 **窗口客户区** 的。
    *   **未识别到任何文本**: 返回一个**空字符串** `""`。
    *   **失败**: 返回固定的字符串 `"-1"`。失败原因可能包括：窗口句柄无效、截图失败、Tesseract引擎初始化失败（例如语言包路径错误）等。
*   **`dllcall` 示例:**
    ```
    // 假设 `窗口句柄` 已被赋值
    var tessdata路径 = "C:\\tessdata"
    var 识别语言 = "chi_sim"
    
    // 返回值类型是 "char *"
    var 结果字符串 = dllcall(dll路径, "char *", "Ocr",
        "long", 窗口句柄,
        "long", 100,         // roiX
        "long", 200,         // roiY
        "long", 300,         // roiWidth
        "long", 50,          // roiHeight
        "char *", 识别语言,
        "char *", tessdata路径
    )
    
    if (结果字符串 == "-1")
        traceprint("函数执行失败")
    else if (结果字符串 == "")
        traceprint("未识别到任何文本")
    else
        // 你可以在脚本里按"|"分割来处理每一个识别结果
        traceprint("识别结果: ", 结果字符串)
    end
    ```

### 10. `OcrFile`

对指定的本地图像文件进行OCR文本识别。这适用于您已经有现成的、预处理好的图片文件的情况。

*   **C++ 签名:**
    ```cpp
    HHAPI const char* __stdcall OcrFile(
        const char* imgPath,
        const char* lang,
        const char* tessdataPath
    );
    ```
*   **参数:**
    *   `imgPath` (`const char*`): 待识别的图像文件路径。
    *   `lang` (`const char*`): 识别语言，同 `Ocr` 函数。
    *   `tessdataPath` (`const char*`): Tesseract 数据路径，同 `Ocr` 函数。
*   **返回值 (`const char*`):**
    *   **成功**: 返回 `"文本1,centerX1,centerY1|文本2,centerX2,centerY2|..."` 格式的字符串。坐标是相对于 **图像本身** 的中心点坐标。
    *   **未识别到任何文本**: 返回一个**空字符串** `""`。
    *   **失败**: 返回固定的字符串 `"-1"`。
*   **`dllcall` 示例:**
    ```
    var 结果字符串 = dllcall(dll路径, "char *", "OcrFile",
        "char *", "C:\\path\\to\\my_image.png",
        "char *", "chi_sim",
        "char *", "C:\\tesseract-data"
    )
    
    if (结果字符串 == "-1")
        traceprint("函数执行失败")
    else if (结果字符串 == "")
        traceprint("未识别到任何文本")
    else
        traceprint("识别结果: ", 结果字符串)
    end
    ```

### 11. `HH_FindText`

在指定窗口的特定区域(ROI)内进行OCR，并查找特定文本字符串的位置。如果找到，返回其中心坐标。

*   **C++ 签名:**
    ```cpp
    HHAPI const char* __stdcall HH_FindText(
        HWND hwnd,
        int roiX,
        int roiY,
        int roiWidth,
        int roiHeight,
        const char* textToFind,
        const char* lang,
        const char* tessdataPath
    );
    ```
*   **参数:**
    *   `hwnd`, `roiX`, `roiY`, `roiWidth`, `roiHeight`, `lang`, `tessdataPath`: 与 `Ocr` 函数相同。
    *   `textToFind` (`const char*`): 要查找的目标文本字符串（区分大小写）。
*   **返回值 (`const char*`):**
    *   **成功找到**: 返回 `"x,y"` 格式的字符串，代表第一个匹配文本的中心点坐标（相对于窗口客户区）。
    *   **未找到**: 返回固定的字符串 `"0"`。
    *   **失败**: 返回固定的字符串 `"-1"`。
*   **`dllcall` 示例:**
    ```
    var 结果字符串 = dllcall(dll路径, "char *", "HH_FindText",
        "long", 窗口句柄,
        "long", 100, "long", 200, "long", 300, "long", 50, // ROI
        "char *", "确定", // 要查找的文本
        "char *", "chi_sim",
        "char *", "C:\\tesseract-data"
    )
    
    if (结果字符串 == "-1")
        traceprint("函数执行失败")
    else if (结果字符串 == "0")
        traceprint("未找到指定的文本")
    else
    // 结果字符串就是 "x,y" 坐标
    traceprint("找到文本，坐标为: ", 结果字符串)
end
```

## OnnxFeature.dll API 参考

### 12. `OnnxCreateSession`

创建 ONNX 目标检测会话并预加载模型，支持会话复用，避免重复加载模型。**该函数会自动初始化ONNX环境**。

*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) int OnnxCreateSession(
        const char* modelPath,
        const char* classNamesPath
    );
    ```
*   **参数:**
    *   `modelPath` (`const char*`): ONNX 模型文件路径
    *   `classNamesPath` (`const char*`): 类名文件路径（每行一个类名）
*   **返回值:**
    *   **成功**: 返回会话ID（1-9999的正整数）
    *   **失败**: 返回 `-1`
*   **`dllcall` 示例:**
    ```
    var sessionId = dllcall("OnnxFeature.dll", "long", "OnnxCreateSession",
        "char *", "C:\\path\\to\\model.onnx",
        "char *", "C:\\path\\to\\classnames.txt"
    )
    
    if (sessionId == -1)
        traceprint("创建会话失败")
    else
        traceprint("会话创建成功，ID: ", sessionId)
    end
    ```

## OnnxFeature.dll API 参考

### 14. `OnnxCreateSession`

创建 ONNX 目标检测会话并预加载模型，支持会话复用，避免重复加载模型。**该函数会自动初始化ONNX环境**。

*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) int OnnxCreateSession(
        const char* modelPath,
        const char* classNamesPath
    );
    ```
*   **参数:**
    *   `modelPath` (`const char*`): ONNX 模型文件路径
    *   `classNamesPath` (`const char*`): 类名文件路径（每行一个类名）
*   **返回值:**
    *   **成功**: 返回会话ID（1-9999的正整数）
    *   **失败**: 返回 `-1`
*   **`dllcall` 示例:**
    ```
    var sessionId = dllcall("OnnxFeature.dll", "long", "OnnxCreateSession",
        "char *", "C:\\path\\to\\model.onnx",
        "char *", "C:\\path\\to\\classnames.txt"
    )
    
    if (sessionId == -1)
        traceprint("创建会话失败")
    else
        traceprint("会话创建成功，ID: ", sessionId)
    end
    ```





### 15. `OnnxDetectImage`

使用会话ID对图像文件进行ONNX目标检测推理。

*   **性能优化**: 该函数使用会话管理机制，自动复用已加载的模型，避免重复加载。
*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) const char* OnnxDetectImage(
        const char* modelPath,
        const char* classNamesPath,
        const char* imagePath,
        double confidenceThreshold
    );
    ```
*   **参数:**
    *   `modelPath` (`const char*`): ONNX模型文件路径
    *   `classNamesPath` (`const char*`): 类名文件路径（每行一个类名）
    *   `imagePath` (`const char*`): 待检测的图像文件路径
    *   `confidenceThreshold` (`double`): 置信度阈值 (0.0 - 1.0)
*   **返回值 (`const char*`):**
    *   **成功**: 返回 `"类别名,置信度,x,y,宽度,高度|..."` 格式的字符串
    *   **未检测到目标**: 返回 `"0"`
    *   **失败**: 返回 `"-1"`
*   **`dllcall` 示例:**
    ```
    var result = dllcall("OnnxFeature.dll", "char *", "OnnxDetectImage",
        "char *", "C:\\path\\to\\model.onnx",
        "char *", "C:\\path\\to\\classnames.txt",
        "char *", "C:\\path\\to\\image.jpg",
        "double", 0.5
    )
    
    if (result == "-1")
        traceprint("ONNX 推理失败")
    else if (result == "0")
        traceprint("未检测到目标")
    else
        traceprint("检测结果: ", result)
    end
    ```

### 16. `OnnxDetectWindow`

对指定窗口截图并进行ONNX目标检测推理。

*   **性能优化**: 该函数自动管理模型会话，支持模型复用。
*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) const char* OnnxDetectWindow(
        const char* modelPath,
        const char* classNamesPath,
        HWND hwnd,
        int roiX,
        int roiY,
        int roiWidth,
        int roiHeight,
        double confidenceThreshold
    );
    ```
*   **参数:**
    *   `modelPath` (`const char*`): ONNX模型文件路径
    *   `classNamesPath` (`const char*`): 类名文件路径（每行一个类名）
    *   `hwnd` (`HWND`): 目标窗口句柄
    *   `roiX`, `roiY`, `roiWidth`, `roiHeight` (`int`): 截图区域 (ROI)，坐标相对于窗口客户区
    *   `confidenceThreshold` (`double`): 置信度阈值 (0.0 - 1.0)
*   **返回值 (`const char*`):**
    *   **成功**: 返回 `"类别名,置信度,x,y,宽度,高度|..."` 格式的字符串，坐标已转换为相对于窗口的绝对坐标
    *   **未检测到目标**: 返回 `"0"`
    *   **失败**: 返回 `"-1"`
*   **`dllcall` 示例:**
    ```
    var result = dllcall("OnnxFeature.dll", "char *", "OnnxDetectWindow",
        "char *", "C:\\path\\to\\model.onnx",
        "char *", "C:\\path\\to\\classnames.txt",
        "long", 窗口句柄,
        "long", 0,            // roiX
        "long", 0,            // roiY
        "long", 1920,         // roiWidth
        "long", 1080,         // roiHeight
        "double", 0.5
    )
    
    if (result == "-1")
        traceprint("窗口截图推理失败")
    else if (result == "0")
        traceprint("未检测到目标")
    else
        traceprint("检测结果: ", result)
    end
    ```

### 17. `OnnxPlugin_Cleanup`

清理 ONNX 推理环境，释放所有资源。

*   **作用**: 释放所有会话和全局的 `Ort::Env` 实例，清理ONNX Runtime占用的所有资源。
*   **特点**: 该函数已集成原有 `OnnxReleaseSession` 的功能，一次性清理所有会话和全局环境。
*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) void OnnxPlugin_Cleanup();
    ```
*   **参数:** 无
*   **返回值:** 无
*   **`dllcall` 示例:**
    ```
    dllcall("OnnxFeature.dll", "void", "OnnxPlugin_Cleanup")
    traceprint("ONNX 环境已清理")
    ```

### 18. `OnnxOcrImage`

使用 ONNX 模型对图像文件进行 OCR 文字识别。该函数支持完整的PaddleOCR架构：文本检测、方向分类（可选）和文字识别。

*   **特点**: 支持PaddleOCR等主流OCR模型的ONNX格式，自动管理模型会话，支持方向自动矫正。
*   **模型架构**: 支持完整的三阶段OCR流程或简化的两阶段流程。
*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) const char* OnnxOcrImage(
        const char* detectionModelPath,
        const char* recognitionModelPath,
        const char* classifierPath,
        const char* imagePath,
        double confidenceThreshold
    );
    ```
*   **参数:**
    *   `detectionModelPath` (`const char*`): OCR文本检测ONNX模型文件路径（必填）
    *   `recognitionModelPath` (`const char*`): OCR文字识别ONNX模型文件路径（必填）
    *   `classifierPath` (`const char*`): OCR方向分类器ONNX模型文件路径（可选，传入NULL或空字符串表示不使用）
    *   `imagePath` (`const char*`): 待识别的图像文件路径
    *   `confidenceThreshold` (`double`): 置信度阈值 (0.0 - 1.0)
*   **返回值 (`const char*`):** 识别结果字符串，格式为：`"文本1,x1,y1,w1,h1|文本2,x2,y2,w2,h2|..."`，
    *   **成功**: 返回识别到的文本和坐标信息
    *   **未识别到文本**: 返回空字符串 `""`
    *   **发生错误**: 返回 `"-1"`
*   **`dllcall` 示例:**
    ```
    // 完整三阶段OCR（使用方向分类器）
    var result = dllcall("OnnxFeature.dll", "char *", "OnnxOcrImage",
        "char *", "C:\\path\\to\\detection_model.onnx",
        "char *", "C:\\path\\to\
    ecognition_model.onnx", 
        "char *", "C:\\path\\to\\classifier_model.onnx",
        "char *", "C:\\path\\to\\image.png",
        "double", 0.5
    )
    
    // 简化两阶段OCR（不使用方向分类器）
    var result = dllcall("OnnxFeature.dll", "char *", "OnnxOcrImage",
        "char *", "C:\\path\\to\\detection_model.onnx",
        "char *", "C:\\path\\to\
    ecognition_model.onnx", 
        "char *", "",
        "char *", "C:\\path\\to\\image.png",
        "double", 0.5
    )
    
    if (result == "-1")
        traceprint("OCR识别失败")
    else if (result == "")
        traceprint("未识别到文本")
    else
        traceprint("识别结果: ", result)
    ```

### 19. `OnnxOcrWindow`

对指定窗口截图并进行 OCR 文字识别。该函数支持完整的PaddleOCR架构：文本检测、方向分类（可选）和文字识别。

*   **特点**: 支持PaddleOCR等主流OCR模型的ONNX格式，自动管理模型会话，坐标相对于窗口客户区，支持方向自动矫正。
*   **模型架构**: 支持完整的三阶段OCR流程或简化的两阶段流程。
*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) const char* OnnxOcrWindow(
        const char* detectionModelPath,
        const char* recognitionModelPath,
        const char* classifierPath,
        HWND hwnd,
        int roiX,
        int roiY,
        int roiWidth,
        int roiHeight,
        double confidenceThreshold
    );
    ```
*   **参数:**
    *   `detectionModelPath` (`const char*`): OCR文本检测ONNX模型文件路径（必填）
    *   `recognitionModelPath` (`const char*`): OCR文字识别ONNX模型文件路径（必填）
    *   `classifierPath` (`const char*`): OCR方向分类器ONNX模型文件路径（可选，传入NULL或空字符串表示不使用）
    *   `hwnd` (`HWND`): 目标窗口句柄
    *   `roiX`, `roiY`, `roiWidth`, `roiHeight` (`int`): 截图区域 (ROI)，坐标相对于窗口客户区
    *   `confidenceThreshold` (`double`): 置信度阈值 (0.0 - 1.0)
*   **返回值 (`const char*`):** 识别结果字符串，格式为：`"文本1,x1,y1,w1,h1|文本2,x2,y2,w2,h2|..."`，
    *   **成功**: 返回识别到的文本和坐标信息（坐标相对于窗口客户区）
    *   **未识别到文本**: 返回空字符串 `""`
    *   **发生错误**: 返回 `"-1"`
*   **`dllcall` 示例:**
    ```
    // 完整三阶段OCR（使用方向分类器）
    var result = dllcall("OnnxFeature.dll", "char *", "OnnxOcrWindow",
        "char *", "C:\\path\\to\\detection_model.onnx",
        "char *", "C:\\path\\to\
    ecognition_model.onnx",
        "char *", "C:\\path\\to\\classifier_model.onnx",
        "long", 窗口句柄,
        "long", 0,            // roiX
        "long", 0,            // roiY
        "long", 1920,         // roiWidth
        "long", 1080,         // roiHeight
        "double", 0.5
    )
    
    // 简化两阶段OCR（不使用方向分类器）
    var result = dllcall("OnnxFeature.dll", "char *", "OnnxOcrWindow",
        "char *", "C:\\path\\to\\detection_model.onnx",
        "char *", "C:\\path\\to\
    ecognition_model.onnx",
        "char *", "",
        "long", 窗口句柄,
        "long", 0,            // roiX
        "long", 0,            // roiY
        "long", 1920,         // roiWidth
        "long", 1080,         // roiHeight
        "double", 0.5
    )
    
    if (result == "-1")
        traceprint("OCR识别失败")
    else if (result == "")
        traceprint("未识别到文本")
    else
        traceprint("识别结果: ", result)
    ```

### 20. `PaddleOcrFindText` - PaddleOCR窗口找字API

使用会话ID对指定窗口区域截图并查找特定文字。这是基于现有OCR功能的精确文字查找API。

*   **特点**: 基于PaddleOCR模型，支持会话复用，自动管理模型加载，坐标返回文字中心点。
*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) const char* PaddleOcrFindText(
        int ocrSessionId,
        HWND hwnd,
        int roiX,
        int roiY,
        int roiWidth,
        int roiHeight,
        const char* targetText,
        double confidenceThreshold
    );
    ```
*   **参数:**
    *   `ocrSessionId` (`int`): OCR会话ID（由`OnnxCreateOcrSession`返回）
    *   `hwnd` (`HWND`): 目标窗口句柄
    *   `roiX`, `roiY`, `roiWidth`, `roiHeight` (`int`): 查找区域 (ROI)，坐标相对于窗口客户区
    *   `targetText` (`const char*`): 要查找的目标文字
    *   `confidenceThreshold` (`double`): 置信度阈值 (0.0 - 1.0)
*   **返回值 (`const char*`):**
    *   **找到文字**: 返回 `"x,y"` 坐标字符串（文字中心点坐标）
    *   **未找到文字**: 返回 `"0"`
    *   **发生错误**: 返回 `"-1"`
*   **`dllcall` 示例:**
    ```
    // 假设 ocrSessionId 已通过 OnnxCreateOcrSession 获取
    var result = dllcall("OnnxFeature.dll", "char *", "PaddleOcrFindText",
        "long", ocrSessionId,
        "long", 窗口句柄,
        "long", 0,            // roiX
        "long", 0,            // roiY
        "long", 1920,         // roiWidth
        "long", 1080,         // roiHeight
        "char *", "确定",      // 要查找的目标文字
        "double", 0.5          // 置信度阈值
    )
    
    if (result == "-1")
        traceprint("PaddleOCR找字失败")
    else if (result == "0")
        traceprint("未找到目标文字")
    else
        traceprint("找到文字，坐标为: ", result)
    ```

### 21. `PaddleOcrFindTextInImage` - PaddleOCR图像找字API

使用会话ID对图像文件进行OCR并查找特定文字。这是基于现有OCR功能的精确文字查找API。

*   **特点**: 基于PaddleOCR模型，支持会话复用，自动管理模型加载，坐标返回文字中心点。
*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) const char* PaddleOcrFindTextInImage(
        int ocrSessionId,
        const char* imagePath,
        const char* targetText,
        double confidenceThreshold
    );
    ```
*   **参数:**
    *   `ocrSessionId` (`int`): OCR会话ID（由`OnnxCreateOcrSession`返回）
    *   `imagePath` (`const char*`): 图像文件路径
    *   `targetText` (`const char*`): 要查找的目标文字
    *   `confidenceThreshold` (`double`): 置信度阈值 (0.0 - 1.0)
*   **返回值 (`const char*`):**
    *   **找到文字**: 返回 `"x,y"` 坐标字符串（文字中心点坐标）
    *   **未找到文字**: 返回 `"0"`
    *   **发生错误**: 返回 `"-1"`
*   **`dllcall` 示例:**
    ```
    // 假设 ocrSessionId 已通过 OnnxCreateOcrSession 获取
    var result = dllcall("OnnxFeature.dll", "char *", "PaddleOcrFindTextInImage",
        "long", ocrSessionId,
        "char *", "C:\\path\\to\\image.png",
        "char *", "确定",      // 要查找的目标文字
        "double", 0.5          // 置信度阈值
    )
    
    if (result == "-1")
        traceprint("PaddleOCR图像找字失败")
    else if (result == "0")
        traceprint("未找到目标文字")
    else
        traceprint("找到文字，坐标为: ", result)
    ```

### 22. `OnnxCreateOcrSession` - 创建OCR会话

创建ONNX OCR会话并预加载PaddleOCR模型，支持会话复用，避免重复加载模型。

*   **特点**: 自动管理OCR模型加载，支持PaddleOCR检测、识别和分类模型的预加载。
*   **C++ 签名:**
    ```cpp
    extern "C" __declspec(dllexport) int OnnxCreateOcrSession(
        const char* detectionModelPath,
        const char* recognitionModelPath,
        const char* classifierPath
    );
    ```
*   **参数:**
    *   `detectionModelPath` (`const char*`): OCR文本检测ONNX模型文件路径（必填）
    *   `recognitionModelPath` (`const char*`): OCR文字识别ONNX模型文件路径（必填）
    *   `classifierPath` (`const char*`): OCR方向分类器ONNX模型文件路径（可选，传入NULL或空字符串表示不使用）
*   **返回值:**
    *   **成功**: 返回OCR会话ID（10000-19999的正整数）
    *   **失败**: 返回 `-1`
*   **`dllcall` 示例:**
    ```
    var ocrSessionId = dllcall("OnnxFeature.dll", "long", "OnnxCreateOcrSession",
        "char *", "C:\\path\\to\\detection_model.onnx",
        "char *", "C:\\path\\to\\recognition_model.onnx",
        "char *", ""  // 不使用方向分类器
    )
    
    if (ocrSessionId == -1)
        traceprint("OCR会话创建失败")
    else
        traceprint("OCR会话创建成功，ID: ", ocrSessionId)
    ```

## 性能优化建议

### ONNX 推理性能优化

当前版本的 `OnnxFeature.dll` 已经内置了会话管理机制，所有推理函数都自动支持模型复用，无需手动管理会话。

#### 推荐的调用方式（简化版）

```
// 直接调用推理函数，无需手动初始化环境
while (true)
    var result = dllcall("OnnxFeature.dll", "char *", "OnnxDetectWindow",
        "char *", "C:\\path\\to\\model.onnx",
        "char *", "C:\\path\\to\\classnames.txt",
        "long", 窗口句柄,
        "long", 0, "long", 0, "long", 1920, "long", 1080,
        "double", 0.5
    )
    // 处理结果...
end

// 可选：程序退出时清理环境
dllcall("OnnxFeature.dll", "void", "OnnxPlugin_Cleanup")
```

#### 简化资源管理

当前版本已简化资源管理，只需在程序退出时调用 `OnnxPlugin_Cleanup()` 即可释放所有资源：

```
// 程序退出时清理所有资源
dllcall("OnnxFeature.dll", "void", "OnnxPlugin_Cleanup")
traceprint("ONNX 环境已清理")
```

**性能对比：**
- **传统方式（无会话管理）**: 每次调用都需要重新加载模型，耗时约 100-500ms
- **当前版本（内置会话管理）**: 首次调用耗时约 100-500ms，后续调用仅需 10-50ms，性能提升 10倍以上

**注意**: 当前所有推理函数（`OnnxDetectImage`、`OnnxDetectWindow`）都内置了会话管理机制，自动复用已加载的模型。

---

## 五、 如何添加新的 API

根据您的需求，可以选择为 HHYolo.dll 或 OnnxFeature.dll 添加新的功能。

### 为 HHYolo.dll 添加新 API

#### 步骤 1: 在头文件 (.h) 中声明函数

打开 `HHYolo.h` 文件，在 `extern "C" { ... }` 代码块中添加您的新函数声明。

*   必须使用 `HHAPI` 和 `__stdcall`。
*   **示例**: 添加一个减法函数。

```cpp
// HHYolo.h

extern "C" {

// ... 已有的函数 ...

/**
 * @brief 示例：计算两个整数的差。
 * @return a - b 的结果。
 */
HHAPI int __stdcall Subtract(int a, int b);

} // extern "C"
```

#### 步骤 2: 在源文件 (.cpp) 中实现函数

打开 `HHYolo.cpp` 文件，在文件末尾添加新函数的具体实现代码。

```cpp
// HHYolo.cpp

// ... 已有的函数实现 ...

// 示例：减法函数的实现
int __stdcall Subtract(int a, int b)
{
    return a - b;
}
```

#### 步骤 3: 在定义文件 (.def) 中导出函数

这是**非常关键**的一步，它能确保您的函数名在DLL中是干净的（没有 `_` 或 `@` 等修饰符）。

打开 `HHYolo.def` 文件，在 `EXPORTS` 列表下添加您的新函数名。

```
; HHYolo.def

EXPORTS
    FindImage
    FindImageFromMem
    CaptureAndFindImage
    CaptureAndFindAllImages
    CaptureAndFindMultiTemplates
    ReadMemory
    FindColor
    AnalyzeGrid
    Ocr
    OcrFile
    HH_FindText
    PaddleOCR_Init
    PaddleOCR_Do
```

### 为 OnnxFeature.dll 添加新 API

#### 步骤 1: 在源文件 (.cpp) 中声明和实现函数

打开 `OnnxFeature.cpp` 文件，在文件末尾添加新函数。OnnxFeature.dll 使用动态导出方式，无需 .def 文件。

```cpp
// OnnxFeature.cpp

// ... 已有的函数实现 ...

// 示例：添加一个简单的 ONNX 工具函数
extern "C" __declspec(dllexport) const char* OnnxGetVersion()
{
    return "1.0.0";
}
```

#### 步骤 2: 无需修改 .def 文件

OnnxFeature.dll 使用 `__declspec(dllexport)` 动态导出函数，无需修改 .def 文件。

### 重新编译

无论为哪个 DLL 添加新功能，都需要重新编译：

```bash
# 确保当前目录是 build 目录
cmake --build . --config Release
```

编译成功后，新的 DLL 文件就会包含您刚刚添加的函数了。

---

## 六、 常见问题解答 (FAQ)

### Q1: 编译时出现 `error LNK2005: _deflate 已经在 zlib.lib(zlib1.dll) 中定义` 错误怎么办？

这个错误是典型的 **库冲突** 问题，也是本项目最容易遇到的坑。

*   **根本原因**: 链接器在最终生成 DLL 时，发现项目里同时存在 **静态版本** (`zlib.lib`) 和 **动态版本** (`zlib1.dll` 的导入库) 的 `zlib` 压缩库，导致函数定义重复，链接器不知道该用哪一个。
*   **触发场景**: 这个问题通常发生在编译环境配置不“纯净”时。例如，直接在普通的 PowerShell 或 CMD 窗口中运行 `cmake`，可能会因为系统环境变量的干扰，导致 CMake 错误地混合引用了不同架构（如 `x64`）或不同类型（动态库）的 vcpkg 依赖，即使您已经安装了正确的 `x86-windows-static` 版本。

*   **解决方案**:
    1.  **严格遵守本文档【三、编译项目】章节推荐的流程**。
    2.  **核心是必须使用 “Developer Command Prompt for VS 2022”**，因为它提供了一个干净、隔离的编译环境。
    3.  **在 `cmake` 命令中明确使用 `-A Win32`**，确保生成的是 32 位项目，与我们的 `x86-windows-static` 库完全匹配。

    只要严格遵循推荐的编译流程，就可以从根源上避免此问题。如果问题依然存在，请尝试执行 `vcpkg remove zlib:x86-windows-static --recurse` 后再重新安装所有依赖，进行一次彻底的净化。